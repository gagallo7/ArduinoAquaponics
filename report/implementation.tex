\subsection{Periodic Water Cycling Code}

%\minisec{Sketch 1: A flashing LED on a protoboard}

\begin{lstlisting}[style=Arduino, caption=Water Cycle First Code, label=lst:water1]
 /*  Emits a periodic signal one quarter per hour */

// Which pin is connected with the water pump?
const int waterPumpPIN = 4;

// Time intervals
// 15 min = 60e3 ms * 15 = 9e5 ms
const int fifteenMin = 900000;
const int fourtyFiveMin = 2700000;

void setup(){
  // Sets the waterPumpPIN as the output of the periodic signal
  pinMode(waterPumpPIN, OUTPUT);
}

void loop(){
  digitalWrite(waterPumpPIN, HIGH); // sets the signal to logical 1 ON
  delay(fifteenMin // stay on high voltage for 15 minutes
  digitalWrite(waterPumpPIN, LOW); // sets the signal to logical 0 OFF
  delay(fourtyFiveMin); // stay on low voltage for 45 minutes
}
\end{lstlisting}

% Make a second code based on https://www.arduino.cc/en/Tutorial/BlinkWithoutDelay
\subsubsection{Reviewed Code}
A program that uses delay in the main loop to make timed actions is error-prone,
since the delay will be belated by the overhead of other operations located inside the main loop.
Moreover the Arduino will not detect any interruption during a delay,
so we need to use delays only when it is really necessary.

To make a better code and to improve the scalability of the automation for more use cases that needs to be precisely timed,
one needs to review the code to find another way to do periodic actions.
We used \cite{arduinoDelay} as a reference to remove the delay-based code from water cycling's code \ref{lst:water1}.

\begin{lstlisting}[style=Arduino, caption=Water Cycle Code without Delays]
 /*  Emits a periodic signal one quarter per hour
     without using delay */

// Which pin is connected with the water pump?
const int waterPumpPIN = 4;

// State of the signal
int waterPumpState = LOW;

// Using unsigned variable to support more data
unsigned long previousMillis = 0;

// Time intervals
// 15 min = 60e3 ms * 15 = 9e6 ms
const int fifteenMin = 9000000;
const int fourtyFiveMin = 27000000;

void setup(){
  // Sets the waterPumpPIN as the output of the periodic signal
  pinMode(waterPumpPIN, OUTPUT);
}

void loop(){
  digitalWrite(waterPumpPIN, HIGH); // sets the signal to logical 1 ON
  delay(fifteenMin // stay on high voltage for 15 minutes
  digitalWrite(waterPumpPIN, LOW); // sets the signal to logical 0 OFF
  delay(fourtyFiveMin); // stay on low voltage for 45 minutes
}
\end{lstlisting}

Note that we are storing the timestamps in a 32-bit variable,
so the overflow will occur in almost 50 days,
because the limit is $ ( 2^{32} -1 ) $ ms.
But there is a fancy property with this overflow that soothes this worry:
the subtraction of two timestamps will remain correct even if there is a overflow in those numbers,
given that the variable is unsigned.
$ limit = FFFF FFFF $
$ limit - 3 seconds = FFFF FFFB $
$ limit + 1 = 0 $
$ 10 seconds = A = limit + B $
$ 0000 000A - FFFF FFFB = 0000 000E = 14 seconds $
